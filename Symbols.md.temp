---
tip: translate by openai@2023-06-24 03:36:13
...
---
description: Symbols (Debugging with GDB)
distribution: global
Generator: makeinfo
keywords: Symbols (Debugging with GDB)
lang: en
resource-type: document
title: Symbols (Debugging with GDB)
---
::: header
Next: [Altering](Altering.html#Altering)]
:::

---

## 16 Examining the Symbol Table


The commands described in this chapter allow you to inquire about the symbols (names of variables, functions and types) defined in your program. This information is inherent in the text of your program and does not change as your program executes. [GDB] (see [Choosing Files](File-Options.html#File-Options)), or by one of the file-management commands (see [Commands to Specify Files](Files.html#Files)).

> 本章描述的命令允许您查询程序中定义的符号（变量、函数和类型的名称）。此信息固有于您的程序文本中，在程序执行过程中不会改变。[GDB]（参见[选择文件](File-Options.html#File-Options)），或者使用文件管理命令之一（参见[指定文件的命令](Files.html#Files)）。


Occasionally, you may need to refer to symbols that contain unusual characters, which [GDB]' as a single symbol, enclose it in single quotes; for example,

> 偶尔，您可能需要引用包含特殊字符的符号，将[GDB]作为单个符号，用单引号括起来；例如，'

::: smallexample

```bash
p 'foo.c'::x
```

:::

looks up the value of `x` in the scope of the file `foo.c`.

`set case-sensitive on`

`set case-sensitive off`

`set case-sensitive auto`


Normally, when [GDB] looks up symbols, it matches their names with case sensitivity determined by the current source language. Occasionally, you may wish to control that. The command `set case-sensitive` lets you do that by specifying `on` for case-sensitive matches or `off` for case-insensitive ones. If you specify `auto`, case sensitivity is reset to the default suitable for the source language. The default is case-sensitive matches for all languages except for Fortran, for which the default is case-insensitive matches.

> 一般来说，当GDB查找符号时，它会根据当前源语言的大小写敏感度进行匹配。有时，您可能希望控制这一点。命令'set case-sensitive'允许您通过指定“on”进行大小写敏感的匹配，或者指定“off”进行大小写不敏感的匹配。如果指定“auto”，则大小写敏感度将重置为适合源语言的默认值。默认情况下，所有语言的匹配都是大小写敏感的，但Fortran的默认情况是大小写不敏感的匹配。

`show case-sensitive`


This command shows the current setting of case sensitivity for symbols lookups.

> 这个命令显示符号查找的当前大小写敏感设置。

`set print type methods`

`set print type methods on`

`set print type methods off`

Normally, when [GDB] to omit the methods.

`show print type methods`


This command shows the current setting of method display when printing classes.

> 这个命令显示了打印类时当前的方法显示设置。

`set print type nested-type-limit limit`

`set print type nested-type-limit unlimited`


Set the limit of displayed nested types that the type printer will show. A `limit` of `unlimited` or `-1` will show all nested definitions. By default, the type printer will not show any nested types defined in classes.

> 设置显示的嵌套类型的限制，类型打印机将显示。`无限`或`-1`的`限制`将显示所有嵌套定义。默认情况下，类型打印机不会显示类中定义的任何嵌套类型。

`show print type nested-type-limit`


This command shows the current display limit of nested types when printing classes.

> 这个命令显示了打印类时嵌套类型的当前显示限制。

`set print type typedefs`

`set print type typedefs on`

`set print type typedefs off`


Normally, when [GDB] to omit the typedef definitions. Note that this controls whether the typedef definition itself is printed, not whether typedef names are substituted when printing other types.

> 通常，当使用GDB时会省略类型定义。注意，这控制的是是否打印类型定义本身，而不是打印其他类型时是否替换类型定义名称。

`show print type typedefs`


This command shows the current setting of typedef display when printing classes.

> 这个命令显示了打印类时类型定义显示的当前设置。

`set print type hex`

`set print type hex on`

`set print type hex off`


When [GDB] prints sizes and offsets of struct members, it can use either the decimal or hexadecimal notation. You can select one or the other either by passing the appropriate flag to `ptype`, or by using the `set print type hex` command.

> 当[GDB]打印结构成员的大小和偏移量时，它可以使用十进制或十六进制表示法。您可以通过传递适当的标志给`ptype`来选择其中一种，或者使用`set print type hex`命令。

`show print type hex`


This command shows whether the sizes and offsets of struct members are printed in decimal or hexadecimal notation.

> 这个命令显示结构体成员的大小和偏移量是以十进制还是十六进制符号打印的。

`info address symbol`


Describe where the data for `symbol` is stored. For a register variable, this says which register it is kept in. For a non-register local variable, this prints the stack-frame offset at which the variable is always stored.

> 对于`symbol`的数据存储在哪里？对于寄存器变量，这表示它存储在哪个寄存器中。对于非寄存器本地变量，这将打印变量总是存储的堆栈帧偏移量。


Note the contrast with '`print &symbol`', which does not work at all for a register variable, and for a stack local variable prints the exact address of the current instantiation of the variable.

> 注意与“print &symbol”的对比，对于寄存器变量完全无效，对于堆栈本地变量则会打印变量当前实例的精确地址。

`info symbol addr`


Print the name of a symbol which is stored at the address `addr` prints the nearest symbol and an offset from it:

> 在地址`addr`存储的符号的名称，打印最近的符号及其偏移量：

::: smallexample

```bash
(gdb) info symbol 0x54320
_initialize_vx + 396 in section .text
```

:::


This is the opposite of the `info address` command. You can use it to find out the name of a variable or a function given its address.

> 这是`info address`命令的相反。您可以使用它来查找给定地址的变量或函数的名称。


For dynamically linked executables, the name of executable or shared library containing the symbol is also printed:

> 对于动态链接的可执行文件，还会打印出包含该符号的可执行文件或共享库的名称。

::: smallexample

```bash
(gdb) info symbol 0x400225
_start + 5 in section .text of /tmp/a.out
(gdb) info symbol 0x2aaaac2811cf
__read_nocancel + 6 in section .text of /usr/lib64/libc.so.6
```

:::

`demangle [-l language] [--] name`

Demangle `name` is demangled in the current language.

The '`--` begins with a dash.


The parameter `demangle-style` specifies how to interpret the kind of mangling used. See [Print Settings](Print-Settings.html#Print-Settings).

> 参数`demangle-style`指定如何解释所使用的编码类型。请参阅[打印设置](Print-Settings.html#Print-Settings)。

`whatis[/flags] [arg]`


Print the data type of `arg`, which can be either an expression or a name of a data type. With no argument, print the data type of `$`, the last value in the value history.

> 打印`arg`的数据类型，它可以是一个表达式或数据类型的名称。如果没有参数，则打印值历史中最后一个值`$`的数据类型。


If `arg` is an expression (see [Expressions](Expressions.html#Expressions)), it is not actually evaluated, and any side-effecting operations (such as assignments or function calls) inside it do not take place.

> 如果`arg`是一个表达式（参见[表达式](Expressions.html#Expressions)），它不会被实际评估，其中的任何具有副作用的操作（如赋值或函数调用）都不会发生。


If `arg` is a variable or an expression, `whatis` prints its literal type as it is used in the source code. If the type was defined using a `typedef`, `whatis` will *not* print the data type underlying the `typedef`. If the type of the variable or the expression is a compound data type, such as `struct` or `class`, `whatis` never prints their fields or methods. It just prints the `struct`/`class` name (a.k.a. its *tag*). If you want to see the members of such a compound data type, use `ptype`.

> 如果`arg`是一个变量或表达式，`whatis`会打印出它在源代码中使用的字面类型。如果类型是使用`typedef`定义的，`whatis`不会打印其底层数据类型。如果变量或表达式的类型是复合数据类型，如`struct`或`class`，`whatis`永远不会打印它们的字段或方法。它只会打印`struct`/`class`名称（也称为其标签）。如果您想查看这类复合数据类型的成员，请使用`ptype`。


If `arg`. However, if that underlying type is also a `typedef`, `whatis` will not unroll it.

> 如果`arg`是一个底层类型，`whatis`将会展开它。但是，如果底层类型也是一个`typedef`，`whatis`将不会展开它。

For C code, the type names may also have the form '`class class-name`'.

`flags` can be used to modify how the type is displayed. Available flags are:

`r`


:   Display in "raw" form. Normally, [GDB] substitutes template parameters and typedefs defined in a class when printing the class' members. The `/r` flag disables this.

> 显示原始形式。通常，GDB会在打印类的成员时，替换类中定义的模板参数和typedefs。`/r`标志将禁用此功能。

`m`

:   Do not print methods defined in the class.

`M`


:   Print methods defined in the class. This is the default, but the flag exists in case you change the default with `set print type methods`.

> 打印类中定义的方法。这是默认值，但是如果使用`set print type methods`更改默认值，则会存在标志。

`t`


:   Do not print typedefs defined in the class. Note that this controls whether the typedef definition itself is printed, not whether typedef names are substituted when printing other types.

> 不要打印在类中定义的typedefs。注意，这控制了是否打印typedef定义本身，而不是在打印其他类型时是否替换typedef名称。

`T`


:   Print typedefs defined in the class. This is the default, but the flag exists in case you change the default with `set print type typedefs`.

> 打印类中定义的类型定义。这是默认值，但是可以通过“set print type typedefs”更改默认值。

`o`


:   Print the offsets and sizes of fields in a struct, similar to what the `pahole` tool does. This option implies the `/tm` flags.

> 打印结构中字段的偏移量和大小，类似于`pahole`工具所做的。此选项包含`/tm`标志。

`x`


:   Use hexadecimal notation when printing offsets and sizes of fields in a struct.

> 使用十六进制标记来打印结构体中的偏移量和字段的大小。

`d`


:   Use decimal notation when printing offsets and sizes of fields in a struct.

> 使用十进制符号打印结构体中的偏移量和字段大小。

```
For example, given the following declarations:

::: smallexample
``` smallexample
struct tuv
{
  int a1;
  char *a2;
  int a3;
};

struct xyz
{
  int f1;
  char f2;
  void *f3;
  struct tuv f4;
};

union qwe
{
  struct tuv fff1;
  struct xyz fff2;
};

struct tyu
{
  int a1 : 1;
  int a2 : 3;
  int a3 : 23;
  char a4 : 2;
  int64_t a5;
  int a6 : 5;
  int64_t a7 : 3;
};
```

:::

Issuing a [ptype /o struct tuv] command would print:

::: smallexample

```bash
(gdb) ptype /o struct tuv
/* offset      |    size */  type = struct tuv {
/*      0      |       4 */    int a1;
/* XXX  4-byte hole      */
/*      8      |       8 */    char *a2;
/*     16      |       4 */    int a3;

                               /* total size (bytes):   24 */
                             }
```

:::

Notice the format of the first column of comments. There, you can find two parts separated by the '`|`' character: the *offset*, which indicates where the field is located inside the struct, in bytes, and the *size* of the field. Another interesting line is the marker of a *hole* in the struct, indicating that it may be possible to pack the struct and make it use less space by reorganizing its fields.

It is also possible to print offsets inside an union:

::: smallexample

```bash
(gdb) ptype /o union qwe
/* offset      |    size */  type = union qwe {
/*                    24 */    struct tuv {
/*      0      |       4 */        int a1;
/* XXX  4-byte hole      */
/*      8      |       8 */        char *a2;
/*     16      |       4 */        int a3;

                                   /* total size (bytes):   24 */
                               } fff1;
/*                    40 */    struct xyz {
/*      0      |       4 */        int f1;
/*      4      |       1 */        char f2;
/* XXX  3-byte hole      */
/*      8      |       8 */        void *f3;
/*     16      |      24 */        struct tuv {
/*     16      |       4 */            int a1;
/* XXX  4-byte hole      */
/*     24      |       8 */            char *a2;
/*     32      |       4 */            int a3;

                                       /* total size (bytes):   24 */
                                   } f4;

                                   /* total size (bytes):   40 */
                               } fff2;

                               /* total size (bytes):   40 */
                             }
```

:::

In this case, since `struct tuv` and `struct xyz` occupy the same space (because we are dealing with an union), the offset is not printed for them. However, you can still examine the offset of each of these structures' fields.

Another useful scenario is printing the offsets of a struct containing bitfields:

::: smallexample

```bash
(gdb) ptype /o struct tyu
/* offset      |    size */  type = struct tyu {
/*      0:31   |       4 */    int a1 : 1;
/*      0:28   |       4 */    int a2 : 3;
/*      0: 5   |       4 */    int a3 : 23;
/*      3: 3   |       1 */    signed char a4 : 2;
/* XXX  3-bit hole       */
/* XXX  4-byte hole      */
/*      8      |       8 */    int64_t a5;
/*     16: 0   |       4 */    int a6 : 5;
/*     16: 5   |       8 */    int64_t a7 : 3;
/* XXX  7-byte padding   */

                               /* total size (bytes):   24 */
                             }
```

:::

Note how the offset information is now extended to also include the first bit of the bitfield.

```



`ptype[/flags] [arg]`

`ptype` accepts the same arguments as `whatis`, but prints a detailed description of the type, instead of just the name of the type. See [Expressions](Expressions.html#Expressions).


Contrary to `whatis`, `ptype` always unrolls any `typedef` s in its argument declaration, whether the argument is a variable, expression, or a data type. This means that `ptype` of a variable or an expression will not print literally its type as present in the source code---use `whatis` for that. `typedef` s at the pointer or reference targets are also unrolled. Only `typedef` s of fields, methods and inner `class typedef` s of `struct` s, `class` es and `union` s are not unrolled even with `ptype`.

> 相反，`ptype`总是展开其参数声明中的任何`typedef`，无论参数是变量、表达式还是数据类型。这意味着变量或表达式的`ptype`不会按照源代码中的类型直接打印---使用`whatis`来实现。指针或引用目标的`typedef`也会被展开。只有`struct`、`class`和`union`的字段、方法和内部`class typedef`的`typedef`即使使用`ptype`也不会被展开。

For example, for this variable declaration:

::: smallexample

```bash
typedef double real_t;
struct complex ;
typedef struct complex complex_t;
complex_t var;
real_t *real_pointer_var;
```

:::

the two commands give this output:

::: smallexample

```bash
(gdb) whatis var
type = complex_t
(gdb) ptype var
type = struct complex {
    real_t real;
    double imag;
}
(gdb) whatis complex_t
type = struct complex
(gdb) whatis struct complex
type = struct complex
(gdb) ptype struct complex
type = struct complex {
    real_t real;
    double imag;
}
(gdb) whatis real_pointer_var
type = real_t *
(gdb) ptype real_pointer_var
type = double *
```

:::


As with `whatis`, using `ptype` without an argument refers to the type of `$`, the last value in the value history.

> 正如`whatis`一样，使用`ptype`而不带参数指的是`$`的类型，即值历史中的最后一个值。


Sometimes, programs use opaque data types or incomplete specifications of complex data structure. If the debug information included in the program does not allow [GDB]'. For example, given these declarations:

> 有时，程序使用不透明的数据类型或复杂数据结构的不完整规范。如果程序中包含的调试信息不允许[GDB]，例如，给出这些声明：

::: smallexample

```bash
    struct foo;
    struct foo *fooptr;
```

:::

but no definition for `struct foo` itself, [GDB] will say:

::: smallexample

```bash
  (gdb) ptype foo
  $1 = <incomplete type>
```

:::


"Incomplete type" is C terminology for data types that are not completely specified.

> "不完整类型"是C语言的术语，指尚未完全指定的数据类型。


Othertimes, information about a variable's type is completely absent from the debug information included in the program. This most often happens when the program or library where the variable is defined includes no debug information at all. [GDB] has no type information shows:

> 有时，变量类型的信息完全缺失于程序中包含的调试信息中。这通常发生在定义变量的程序或库中没有任何调试信息的情况下。[GDB]没有类型信息显示：

::: smallexample

```bash
  (gdb) ptype var
  type = <data variable, no debug info>
```

:::


See [no debug info variables](Variables.html#Variables), for how to print the values of such variables.

> 查看[无调试信息变量](Variables.html#Variables)，了解如何打印这些变量的值。

`info types [-q] [regexp]`


Print a brief description of all types whose names match the regular expression `regexp`' gives information only on types whose complete name is `value`.

> 打印出所有完整名称为`value`的类型的简要描述，这些类型的名称与正则表达式`regexp`匹配。


In programs using different languages, [GDB]' (see [Set Language Automatically](Automatically.html#Automatically)) means to use the language of the type, other values mean to use the manually specified language (see [Set Language Manually](Manually.html#Manually)).

> 在使用不同语言的程序中，[GDB]（参见[自动设置语言](Automatically.html#Automatically)）意味着使用类型的语言，其他值意味着使用手动指定的语言（参见[手动设置语言](Manually.html#Manually)）。


This command differs from `ptype` in two ways: first, like `whatis`, it does not print a detailed description; second, it lists all source files and line numbers where a type is defined.

> 这个命令与`ptype`有两点不同：首先，像`whatis`一样，它不会打印详细的描述；其次，它会列出定义类型的所有源文件和行号。


The output from '`into types`', disables printing this header information.

> 将"输出"设置为"禁用打印此标题信息"，可以禁止打印此标题信息。

`info type-printers`


Versions of [GDB] that ship with Python scripting enabled may have "type printers" available. When using `ptype` or `whatis`, these printers are consulted when the name of a type is needed. See [Type Printing API](Type-Printing-API.html#Type-Printing-API), for more information on writing type printers.

> 版本的GDB附带有Python脚本功能，可能会提供“类型打印机”。当使用`ptype`或`whatis`时，这些打印机会在需要类型名称时被查询。有关编写类型打印机的更多信息，请参阅[类型打印API](Type-Printing-API.html#Type-Printing-API)。

`info type-printers` displays all the available type printers.

`enable type-printer name…`

`disable type-printer name…`

These commands can be used to enable or disable type printers.

`info scope locspec`


List all the variables local to the lexical scope of the code location that results from resolving `locspec`. For example:

> 列出所有局部变量，它们属于从解析`locspec`得到的代码位置的词法作用域。例如：

::: smallexample

```bash
(gdb) info scope command_line_handler
Scope for command_line_handler:
Symbol rl is an argument at stack/frame offset 8, length 4.
Symbol linebuffer is in static storage at address 0x150a18, length 4.
Symbol linelength is in static storage at address 0x150a1c, length 4.
Symbol p is a local variable in register $esi, length 4.
Symbol p1 is a local variable in register $ebx, length 4.
Symbol nline is a local variable in register $edx, length 4.
Symbol repeat is a local variable at frame offset -8, length 4.
```

:::

