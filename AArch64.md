---
tip: translate by openai@2023-06-23 16:51:31
...
---
description: AArch64 (Debugging with GDB)
distribution: global
Generator: makeinfo
keywords: AArch64 (Debugging with GDB)
lang: en
resource-type: document
title: AArch64 (Debugging with GDB)
-----------------------------------

::: header
Next: [i386](i386.html#i386)]
:::

---

#### 21.4.1 AArch64

When [GDB] is debugging the AArch64 architecture, it provides the following special commands:

> 当 GDB 调试 AArch64 架构时，它提供了以下特殊命令：

`set debug aarch64`

:

```
This command determines whether AArch64 architecture-specific debugging messages are to be displayed.
```

`show debug aarch64`

:   Show whether AArch64 debugging messages are displayed.

> 显示 AArch64 调试消息是否显示。

#### 21.4.1.1 AArch64 SVE.

When [GDB] will provide the vector registers `$z0` through `$z31`, vector predicate registers `$p0` through `$p15`, and the `$ffr` register. In addition, the pseudo register `$vg` will be provided. This is the vector granule for the current thread and represents the number of 64-bit chunks in an SVE `z` register.

> 当 GDB 提供向量寄存器$z0到$z31，向量谓词寄存器$p0到$p15 以及$ffr寄存器时，此外还提供伪寄存器$vg，这是当前线程的向量粒度，表示 SVE z 寄存器中的 64 位块数量。

If the vector length changes, then the `$vg` register will be updated, but the lengths of the `z` and `p` registers will not change. This is a known limitation of [GDB] and does not affect the execution of the target process.

> 如果向量长度发生变化，那么 `$vg` 寄存器将会被更新，但 `z` 和 `p` 寄存器的长度不会发生变化。这是[GDB]的一个已知限制，不会影响目标进程的执行。

#### 21.4.1.2 AArch64 Pointer Authentication.

When [GDB] is debugging the AArch64 architecture, and the program is using the v8.3-A feature Pointer Authentication (PAC), then whenever the link register `$lr` is pointing to an PAC function its value will be masked. When GDB prints a backtrace, any addresses that required unmasking will be postfixed with the marker \[PAC]. When using the MI, this is printed as part of the `addr_flags` field.

> 当[GDB]在调试 AArch64 架构时，如果程序使用 v8.3-A 特性指针认证(PAC)，那么每当链接寄存器'$lr'指向 PAC 函数时，其值将被屏蔽。当 GDB 打印回溯时，任何需要解除屏蔽的地址都将以标记\[PAC]作为后缀。当使用 MI 时，它将作为 `addr_flags` 字段的一部分打印出来。

#### 21.4.1.3 AArch64 Memory Tagging Extension.

When [GDB] will make memory tagging functionality available for inspection and editing of logical and allocation tags. See [Memory Tagging](Memory-Tagging.html#Memory-Tagging).

> 当 GDB 将内存标记功能提供用于检查和编辑逻辑和分配标记时，请参见[内存标记](Memory-Tagging.html#Memory-Tagging)。

To aid debugging, [GDB] will output additional information when SIGSEGV signals are generated as a result of memory tag failures.

> 为了帮助调试，当内存标签失败导致 SIGSEGV 信号产生时，[GDB]将输出额外的信息。

If the tag violation is synchronous, the following will be shown:

> 如果标签违规是同步的，将会显示以下内容：

::: smallexample

```bash
Program received signal SIGSEGV, Segmentation fault
Memory tag violation while accessing address 0x0500fffff7ff8000
Allocation tag 0x1
Logical tag 0x5.
```

:::

If the tag violation is asynchronous, the fault address is not available. In this case [GDB] will show the following:

> 如果标签违规是异步的，故障地址不可用。在这种情况下，[GDB]会显示以下内容：

::: smallexample

```bash
Program received signal SIGSEGV, Segmentation fault
Memory tag violation
Fault address unavailable.
```

:::

A special register, `tag_ctl`, is made available through the `org.gnu.gdb.aarch64.mte` feature. This register exposes some options that can be controlled at runtime and emulates the `prctl` option `PR_SET_TAGGED_ADDR_CTRL`. For further information, see the documentation in the Linux kernel.

> 特殊寄存器 `tag_ctl` 可通过 `org.gnu.gdb.aarch64.mte` 特性使用。该寄存器暴露了一些可在运行时控制的选项，并模拟 `prctl` 选项 `PR_SET_TAGGED_ADDR_CTRL`。有关更多信息，请参阅 Linux 内核中的文档。

[GDB] supports dumping memory tag data to core files through the `gcore` command and reading memory tag data from core files generated by the `gcore` command or the Linux kernel.

> GDB 支持通过 `gcore` 命令将内存标签数据转储到核心文件中，并且可以从由 `gcore` 命令或 Linux 内核生成的核心文件中读取内存标签数据。

When a process uses memory-mapped pages protected by memory tags (for example, AArch64 MTE), this additional information will be recorded in the core file in the event of a crash or if [GDB] generates a core file from the current process state.

> 当一个进程使用被内存标签保护的内存映射页面（例如，AArch64 MTE）时，如果发生崩溃或[GDB]从当前进程状态生成核心文件，将记录此附加信息到核心文件中。

The memory tag data will be used so developers can display the memory tags from a particular memory region (using the '`m`' modifier to the `x` command, using the `print` command or using the various `memory-tag` subcommands.

> 内存标签数据将被用来让开发者从特定的内存区域显示内存标签（使用'`m`'修饰符来使用 `x` 命令，使用 `print` 命令或使用各种 `memory-tag` 子命令）。

In the case of a crash, [GDB] will attempt to retrieve the memory tag information automatically from the core file, and will show one of the above messages depending on whether the synchronous or asynchronous mode is selected. See [Memory Tagging](Memory-Tagging.html#Memory-Tagging). See [Memory](Memory.html#Memory).

> 在崩溃的情况下，[GDB]将自动从核心文件中检索内存标签信息，并根据选择的同步或异步模式显示上述消息之一。参见[内存标记](Memory-Tagging.html#Memory-Tagging)。参见[内存](Memory.html#Memory)。

---

::: header
Next: [i386](i386.html#i386)]
:::
